To do
=====

Compiler

  deferred code generation
    use transactions which say "add this flow to that state/class",
        "add this guard to that transition", etc.
    can sort and separate into files before committing
      check, per file, for equality with last compile
    retargetable to C or Ruby output
    

Syntax

  run can take seconds as arg
    run :steps => n
    run :time => n

  Fix the option-block cruft--its slow and clunky

  resets and even assignment to cont-vars can use '<=' or '[]='
  better: eval each setup or reset block in a context in which
          for each continuous var a local var of the same name
          has been initialized to nil, and then make the
          assignments later -- won't work
  use this: reset { x expr; y expr; ... }
    where x, y, ... are the only methods in the context (instance_eval)
    they take three kinds of args:
      x 1         --- reset to compile-time constant
      x "..."     --- reset to value of C expr
      x {...}     --- reset to value of Ruby code
      (OR SEE BELOW)

  check for symbol conflicts
    user attributes may conflict with Component's attrs/methods
    ditto for flows and other methods defined in subclasses
    can we 'hook' method def and attr def to check for conflict? 
    or just use a consistent naming scheme to keep internals separate?

  multiple resets and actions for transitions
  
  flows: allow numeric constants
  
  reset clauses:
    transition A => B do
      reset " x := expr ", ... (OR SEE ABOVE)
    setup and defaults, too
    this might get around the self.x danger for casual users
    OR: don't use 'foo = ...' in resets, use 'foo ...' instead
      but thid has the danger of being used in the wrong way in other contexts
    OR: use string syntax and eval the block against a binding which ...
      but inefficient

? 'when' as alias for 'guard'
x if "flow :state" or "transition :state => :other-state"
    lookup or generate a state with that name
  defining and creating components
x   classes should have a "static setup" clause
x     because of commit, cannot create components statically
x     (THIS IS A PROBLEM)
x     actually, this is consistent with having Worlds:
x       you can't create a Component statically, because you don't
x       have a world yet
  world subclasses and individual worlds should have chainable static
    setup clauses
    
/   need to prevent calling new on Component class
    create ... block
      shouldn't use instance_eval but instead run in the caller's context?
      better: use hash of 'var => value, ...'
/   defaults { ... }  and setup { ... }
    state methods: flow Foo { def ... }
      generalization of alg flows
/ flows, transitions, etc.
    deftly handle multiple actions in a transition, etc.
      (chain the blocks?)
  subflows, as in shift (maybe by defining a method on FlowParser?)
? state S1, S2, ... should set S as init state
? input, output, connect -- see tank_monit.rb
  c-shift translator (both ways)
  redshift parser to make flows etc. nicer
    invoke by putting /usr/bin/env redshift in header
    allows nedit syntax mode for redshift
    syntax checking for 'action { x = 3 }', newlines which change meaning, etc.
  static data typing
    setters for flows should check for data type
    flows should have a declared data type
  don't allow lower case state names
x should time-step automatically be converted to Float?

Semantics

  add reset clause to transitions (in effect, like L-S)
    transition ...
      reset :x => { <expression> }
      reset "my_array[10,20]" => { <expression> }
      
    Not lovely, but clear enough. The array string will get eval-ed
    (once!) into a lambda which assigns to the position in the array.
    
    reset "x=y","z=w"
      OR: action "x=y","z=w" do ... end
        where the block is treated as actions were before
        I'm not sure I like this...
    evaluated in parallel for all components which are taking transitions at
      a particular discrete time
    guard guaranteed to be true during eval of RHS, if no side effects
    precedes action
      actions are still evaluated in sequence and allow arb. code
      no guarantees--up to programmer to control concurrency
  
  semaphores on variables to control concurrency in action clauses
    but there's no way to wait for resource to become free
    need a multiplexed global which says "which component is active"
      actually, world.rb has this
    accessors can check this global
    but who has write priority?
      how is contention handled deterministically?
      does it generate an exception when two components ask for the same
        write lock at the same time? Or is it a program error?
    need exception handlers
    
  exception handler clauses in transitions (or use interrupts?)
    on LockFailed { |var, value| ... }
  
  state stack:
    a transition (or interrupt) can push the current state or pop back
      to a previously saved state (like Kader's idea)
    syntax:
      transition ... do
        push [or pop, in which case the dest. state is ignored]
      end
  
  interrupts
    a way of enabling a transition without evaluating guards
      -faster
    can do sender-receiver, rather than broadcast
    can register with global interrupt manager
      notify after T seconds
      notify when global event happens (like what?)
    should interrupts be in a priority queue for the receiving component?
    receive in any state, switch to new state optional (push ok)
    synchronous in the sense that no other components act in between
      the send and receive, and the receiver action happens before the
      sender action finishes (?)
    but not parallel assignment
    based on methods
    in sender's action clause: 'x.foo args'
    in receiver:
      interrupt :foo => NewState do
        action { |args| ...}
        event ...
      end
      
                  timely    lossless    nonblocking
    interrupts:     --         XX           XX
    events:         XX         --           XX
    sync:           XX         XX           --
  
  signals
    maybe better than interrupts, more general
    
    transition ... do
      signal value => receiver_collection, ...
    end
    
    on value do ... end
    
    is this better than a simple method call?
      yes: can implement queue

/ inheritance
/   explicit, calculated before run, cached
/   implicit, based on ruby inheritance
/   Exit transition
/   trans.name = nil to prevent hiding
  inheritance from mixins

  Possible to arrange discrete stuff so other semantics is pluggable?
  
? indeterminate transitions chosen randomly, as an option
    randomize order of component list, and order of transition lists?

  in create(Comp) { ... }, should arrive at Enter before evaling block?
    otherwise flow methods don't work in block

  math
    fixed point, rational integration?
/   complex numbers
    matrices, lapack, etc
    maybe override integer division to output float?
      use 'require "mathn"; include Math", like irb -m.
  
  metaclasses
  
  discrete evolution
    more flexibility:
      start actions as well as finish actions
      (before/after)
      enter and exit blocks for each state
      start_when and finish_when to implement sync
    transitions like in statechart
    parametric transitions?
    attach :all, ...
    syncronization
      explicit?
    events that persist until sender changes state (or end of discrete step?)
?   allow event of transition to be a block or proc returning the events

  exceptions
    catch them if they arise in action
    pass them on to handler where?

Metasimualtion layer
  methods to tell an object to change state, etc.
  method to send message to object(s)

Implementation

  is it possible to give a hint/declaration to the effect that a guard
    refers only to continuous values, so only needs to be checked once
    per time-step?

  use eval %{ ... } instead of eval <<END ... END
  
* for flow/transition inheritance, use instance vars of singleton classes:
    def A.set_flows f; @flows = f; end
    and x.class.get_flows
    don't use class vars in meta.rb

  use alias instead of def in Event#(un)export
    or use extend_object
  
  abstract hash-inheritance and use it in meta.rb and option-block.rb

  optimization
    compiler flags
      -O{1-4}
      -ffast-math
      If these matter much, there should be a switch, like REDSHIFT_OPTIMIZE=n
    in ruby 1.7, convert proc to methods (e.g., the guard method of a trans)
    don't use Data_Get_Struct in flow fns, use simple casts like in
      step_discrete inlines, with asserts
    profiling
    compare with shift, matlab
    integration method
    flows
      algebraic flows should override update (to do nothing)
        instead of having a setter do nothing. Then the setter
        should raise an exception.
    guards
      clause to set how often the guard is checked
      constant guards:
        guard "x > 1"
    dual mode
  
/ garbage collection
/   nil out the components array, do GC, reconstruct components array
x   do this periodically if user sets flag

  math
/   runge-kutta 4
/?  mixing runge-kutta 4 with euler
      justify '$RK_level < 2'
    var step
    symbolic integration
    other integrators:
      average x' at endpoints to get approx. delta_x
x   automatically scan formulas and use best alg.

  debugging, logging
    use AspectR, alias
  
  run time error checking
    more 'if $DEBUG ...' checks
/     use $DEBUG when testing.
/   catch infinite loops in alg. flows
    zeno
      limit can scale w/ num components
    catch definition of flows after commit, etc.
    error reporting: use Minero Aoki's must.rb to check types etc.
    
  exception handling
    syntax and math errors, esp. in flows, guards
    use Exception classes
  
  unit tests
    migrate to TestUnit
/   integrator (start with solution involving diff'able fns)
/   inheritance
/   transitions and events
  
  system tests
    compare with other integrators (accuracy)
    
/ test windows version
  
  World#copy (use marshal, and the tricks in save/open)
  World#== (recursively compare component list)
  Component#== ?
  
/ persistence
    persist_name of nested state shouldn't be :C::S1 ?
    make CShadow data persist by temporarily caching in in a hash
  
  distributed processing

User interface

  command-line debugger, interactive redshift (irs)
    inspect methods
    catch ^C --> redshift should break into debugger, by default
    'run' in a thread, or in sub-irb shell (with self = world)
    send event from outside
  
  run command
    should add dt, zeno, steps, time (in sec) in optBlock
      run N { dt = ...; zeno = ... }
/   pass block to run before/after each timestep
    run_while, run_until
      steps N, time T, continuous, discrete
      run { while {...} }
    next_transition
  
  nedit syntax coloring
    
  gui debugger

/ output to gnuplot
    use pipe for simple animation?

Examples
  http server for simulation, html interface
  matrices
  distributed
/ persistence

Documentation

  restrictions
    singleton methods will be lost in World#save
    can't use modules to define flows, transitions, etc.
